<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="three.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="stats.min.js"></script>

		<script>
			var stats;

			var camera, controls, scene, renderer;
			init();
			render(); // remove when using next line for animation loop (requestAnimationFrame)
			//animate();
			function init() {
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.x = -80;
				camera.position.y = 180;
				camera.position.z = 70;
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // remove when using animation loop
					// enable animation loop when using damping or autorotation
					//controls.enableDamping = true;
					//controls.dampingFactor = 0.25;
				controls.enableZoom = true;
					// world
				var geometry = new THREE.SphereGeometry( 5, 32, 32 );

				function renderLed(posX, posY, posZ) {
					var ledOff = new THREE.MeshPhongMaterial( { color: 0x000 } );
					var mesh = new THREE.Mesh( geometry, ledOff );
					mesh.position.x = posX;
					mesh.position.y = posY;
					mesh.position.z = posZ;
					mesh.updateMatrix();
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );
					render();
					return mesh;
				};
				arrX = [];
				for(x=1;x<5;x++) {
					for(y=1;y<5;y++) {
						for(z=1;z<5;z++) {
							arrX.push(renderLed(x*20,y*20,z*20));
						}
					}
				}
				
				arrX[1].material.color.setHex( 0xff0000 );

				const animations2 = [
				    0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
				    0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
				    0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
				    0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0
				];

				const animations = [
				    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
				    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
				    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
				    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0
				];

				const tab = [animations2, animations];

				function changeColor(argument, n) {
					if(n > tab.length) {
						return;
					}

					for(i=0 ; i <= arrX.length ; i++) {
						if(argument[i] === 1) {
							arrX[i].material.color.setHex( 0xff0000 );
							arrX[i].material.needsUpdate = true;
						} else if(argument[i] === 0) {
							arrX[i].material.color.setHex( 0x000000 );
							arrX[i].material.needsUpdate = true;
						}
						render();
					}
					setTimeout(() => changeColor(tab[n], n+1), 2000);
				}
				changeColor(tab[0], 1);
				
				// lights
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );
				var light = new THREE.DirectionalLight( 0x002288 );
				light.position.set( -1, -1, -1 );
				scene.add( light );
				var light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );
				//
				stats = new Stats();
				container.appendChild( stats.dom );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
				stats.update();
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>